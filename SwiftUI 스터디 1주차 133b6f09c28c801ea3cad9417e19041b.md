# SwiftUI 스터디 1주차

# 🌟키워드🌟

# 1. SwiftUI가 뭘까요? UIKit과 다른 점은 뭔지 알아봅시다!

<aside>
📌

SwiftUI는 Apple의 최신 UI 프레임워크로, 선언형 프로그래밍 방식을 사용합니다. 
UIKit과 비교할 때, SwiftUI의 장점과 단점, 두 프레임워크의 차이점을 조사해보세요~!

</aside>

## SwiftUI의 장점

- SwiftUI는 Apple이 2019년에 도입한 선언적 Swift 프레임워크입니다. 선언적 문법을 사용하여 UI를 구성하기 때문에 코드가 간결하고 이해하기 쉽습니다. 명령에 의해서 상태를 변경하는 것이 아니라 사용하는 곳에서 바뀔 행동과 상태를 선언해둠으로써 사용하게 됩니다.
    
    ```swift
    import SwiftUI
    
    struct ContentView: View {
    
        @State var isButtonTapped: Bool = true
    
        var body: some View {
            VStack {
                Rectangle()
                    .foregroundColor(isButtonTapped == true ? .green: .red)
                Button {
                    isButtonTapped.toggle()
                } label: {
                    Text("색 변환")
                }
            }
        }
    }
    
    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
        }
    }
    ```
    
    ### @State와 구조체
    
    ```swift
    @State var isButtonTapped: Bool = true
    ```
    
    - `@State`는 SwiftUI에서 뷰의 상태를 관리하는 속성입니다. Swift의 `struct`는 변경 불가능한(immutable) 특성을 가지지만, SwiftUI에서는 `@State` 속성을 사용해 구조체 안에서도 변경 가능한(mutable) 속성을 관리할 수 있습니다.
    - `@State`를 사용하면 해당 속성의 값이 변경될 때마다 SwiftUI가 자동으로 뷰를 다시 렌더링하여 사용자 인터페이스가 상태에 맞게 업데이트됩니다.
    - UIKit은 변수가 변경될 때 수동으로 `UIView`의 속성 값을 업데이트해야 하는데, SwiftUI는 `@State` 속성으로 UI를 자동으로 다시 그립니다.
    
    ### 상태에 따라 뷰의 모양 변경
    
    ```swift
    Rectangle()
        .foregroundColor(isButtonTapped ? .green : .red)
    ```
    
    - SwiftUI에서는 상태에 따라 뷰가 어떤 식으로 변할지 선언할 수 있습니다. 여기서는 **Rectangle**의 색상이 **isButtonTapped**의 상태에 따라 초록색(.green) 또는 빨간색(.red)으로 설정됩니다.
        
        ⇒ **SwiftUI가 자동으로 상태를 추적하고, 값이 바뀔 때 해당 상태와 관련된 UI 요소를 다시 렌더링**
        
    
    ### SwiftUI의 레이아웃 시스템(VStack, HStack 등)
    
    ```swift
    VStack {
        Rectangle()
        Button {
            isButtonTapped.toggle()
        } label: {
            Text("색 변환")
        }
    }
    ```
    
    - **VStack**과 **HStack**은 SwiftUI에서 뷰를 수직 또는 수평으로 배치하는 기본적인 레이아웃 컨테이너입니다. UIKit의 경우 각 뷰의 위치와 크기를 일일이 설정해야 하고 주로 Auto Layout이나 frame을 이용하여 위치를 지정하는데 이 점은 SwiftUI가 훨씬 편리하겠죠?
    - SwiftUI는 자동으로 레이아웃을 조정해주므로, 각 뷰의 간격이나 위치를 수동으로 지정할 필요가 없어 코드가 훨씬 간결해집니다. 여기서는 VStack을 통해 Rectangle과 Button을 수직으로 정렬하고 있습니다.
- SwiftUI는 라이브 프리뷰 기능을 제공하여 실시간으로 UI 변경 사항을 볼 수 있게 해줍니다. 개발자가 코드를 수정하고 결과를 즉시 확인할 수 있게 해주어 개발 과정을 크게 단축시킬 수 있게 됩니다.
- SwiftUI는 크로스 플랫폼 개발을 지원하여 한 번의 코드 작성으로 iOS, macOS, watchOS, tvOS에서 실행할 수 있는 앱을 만들 수 있습니다. 왜냐하면 SwiftUI는 플랫폼별 UI 요소를 추상화하여 제공하기 때문입니다.
- SwiftUI는 로운 Apple 플랫폼의 기능을 쉽게 통합할 수 있도록 설계되었기 때문에 간단한 UI를 가진 앱이나 프로토타이핑, 그리고 최신 Apple 플랫폼 기능을 빠르게 도입할 때 유리합니다.

**BUT** SwiftUI는 아직 모든 UIKit의 기능을 대체하지 못하므로 일부 복잡한 UI 구현이나 세밀한 컨트롤이 필요한 경우에는 UIKit을 사용해야 합니다.

## UIKit과의 비교

- SwiftUI는 선언적 방식으로, UI가 상태에 따라 어떻게 변화할지를 선언만 해두면 상태 변화에 따라 UI가 자동으로 업데이트됩니다.
- UIKit은 절차적 방식으로, 특정 이벤트에 따라 상태가 바뀌면 UI 요소의 속성을 직접 업데이트해주어야 합니다.
- 이 차이로 인해 SwiftUI는 코드량이 줄어들며, 가독성과 유지보수성이 향상됩니다. SwiftUI에서 상태가 변하면 뷰가 알아서 리렌더링되기 때문에, 코드에서 UI 갱신에 대한 명령을 줄여 코드가 더 간결해집니다.
- 위에서 보여드린 코드를 UIKit으로 구현하면 아래와 같습니다. 코드가 훨씬 길어지고 복잡해진 걸 볼 수 있습니다.
    
    ```swift
    import UIKit
    
    class ViewController: UIViewController {
        let changeButton = UIButton()
        let mainView = UIView()
    
        override func viewDidLoad() {
            super.viewDidLoad()
            self.view.backgroundColor = .white
    
            mainView.translatesAutoresizingMaskIntoConstraints = false
            changeButton.translatesAutoresizingMaskIntoConstraints = false
            mainView.backgroundColor = .red
            changeButton.addTarget(self, action: #selector(changeColor), for: .touchUpInside)
            self.view.addSubview(mainView)
            self.view.addSubview(changeButton)
            changeButton.setTitle("바꾸기", for: .normal)
            changeButton.setTitleColor(.gray, for: .normal)
    
            NSLayoutConstraint.activate([
                mainView.topAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.topAnchor),
                mainView.leadingAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.leadingAnchor),
                mainView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor),
                mainView.bottomAnchor.constraint(equalTo: changeButton.topAnchor),
    
                changeButton.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),
                changeButton.trailingAnchor.constraint(equalTo: self.view.trailingAnchor),
                changeButton.bottomAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.bottomAnchor),
    
            ])
        }
    
        @objc func changeColor(_ sender: UIButton) {
            mainView.backgroundColor = .green
        }
    }
    ```
    

## UIKit의 장점

UIKit는 iOS 개발에서 오랜 기간 동안 사용되어 온 프레임워크로, 방대한 양의 리소스와 커뮤니티 지원을 제공합니다. 왜냐하면 UIKit는 iOS 개발의 초기부터 사용되어 왔으며, 수많은 앱 개발 프로젝트에서 검증되었기 때문입니다.

UIKit는 다양한 UI 컴포넌트와 강력한 애니메이션 API를 제공하기 때문에 세밀한 UI 컨트롤과 복잡한 애니메이션 구현이 가능하여, 고도로 사용자 정의된 UI를 만들 수 있습니다.  

UIKit는 이전 버전의 iOS와의 호환성을 유지하며, 오래된 프로젝트나 복잡한 비즈니스 로직을 가진 앱에 적합합니다. 왜냐하면 UIKit는 다양한 iOS 버전에서 안정적으로 작동하도록 설계되었기 때문입니다.

UIKit를 사용하는 경우는 SwiftUI로 구현하기 어려운 복잡한 UI가 필요하거나, 기존에 UIKit를 사용하여 개발된 프로젝트를 유지보수해야 할 때입니다. UIKit는 세밀한 UI 컨트롤과 광범위한 기능을 제공하여 복잡한 요구 사항을 충족시킬 수 있기 때문입니다.

## 정리

<aside>
💡

**SwiftUI**는 선언적 문법과 라이브 프리뷰를 통해 개발 과정을 단축시키고, 크로스 플랫폼 개발을 지원하기 때문에 빠른 개발과 프로토타이핑, 간단한 UI를 가진 앱 개발에 적합하며, 최신 Apple 플랫폼 기능을 쉽게 도입하고자 할 때 유리합니다.
**UIKit**은 복잡한 UI와 세밀한 컨트롤이 필요한 앱, 이전 버전의 iOS와의 호환성을 유지해야 하는 프로젝트에 적합합니다. 

</aside>

## 2. SwiftUI에서 View를 그리는 방법에 대해 알아봅시다!

<aside>
📌

SwiftUI에서 뷰를 정의하는 기본적인 방법과 상태(State)에 따라 UI가 자동으로 다시 그려지는 방식을 이해해봅시다

</aside>

1️⃣ 뷰는 뷰를 그리기 위한 데이터가 필요하다.

2️⃣ 뷰에서 사용하고 싶은 데이터, 값이 변했을 때 뷰를 업데이트 하고 싶은 데이터에 표시를 해 SwiftUI가 알아챌 수 있도록 해준다.

3️⃣ 이제 SwiftUI가 뷰와 데이터 사이의 의존 관계를 추적할 수 있게 됐다. 나머진 전부 다 SwiftUI에게 맡기면 된다. 알아서 데이터가 변하면 자동으로 UI를 업데이트해준다!

### Property Wrapper

도구들의 생김새를 보면 대부분 @가 앞에 붙어있습니다.

Property Wrapepr는 프로퍼티를 선언할 때 앞에 붙이는 @로 시작하는 것으로, 말 그대로 Property를 Wrap해서(감싸서) 미리 정의해둔대로 행동하도록 하는 장치입니다.

SwiftUI에서는 Property Wrapper를 다음과 같이 씁니다.

- data flow를 컨트롤
- 즉, 해당 뷰와 의존관계를 가지고 있는 데이터를 표시하기 위해 사용→ property wrapper와 함께 쓰인 데이터가 변경되면 뷰가 업데이트

### Data Flow를 위한 도구의 역할

- 데이터의 변화를 보고있다가 변화가 생기면 그 데이터와 관련된 뷰를 업데이트하도록 도와줍니다.
- Single Source Of Truth를 유지하도록 도와줍니다.

### [SwiftUI가 데이터의 변화를 알아채도록 표시해주는 도구]

### 📲 Property, @State, @Binding

아래와 같은 앱을 만들어보려고 합니다. 뷰와 데이터간의 의존관계를 어떻게 설정해야 효율적으로 데이터의 변화에 따라 뷰를 업데이트할 수 있을까요?

![https://velog.velcdn.com/images/nala/post/69c71aff-6dd3-40f7-be95-c55a23fe6a2b/image.png](https://velog.velcdn.com/images/nala/post/69c71aff-6dd3-40f7-be95-c55a23fe6a2b/image.png)

## Property

해당 정보를 뷰에 보여주기만 하는 경우, 즉 데이터가 변함에 따라 뷰를 업데이트 하지 않아도 되는 경우 그냥 프로퍼티를 쓸 수 있습니다.

예를 들어 메인 페이지인 List를 만드는 경우, 이미 정해져있는 데이터를 보여주기만 해도되기때문에 뷰에 일반 프로퍼티로 데이터를 전달해도 됩니다.

```swift
struct BookCard: View {
    let book: Book
    let progress: Double

    var body: some View {
        HStack {
            BookCover(book.coverName)
            VStack(alignment: .leading) {
                TitleText(book.title)
                AuthorText(book.author)
            }
            Spacer()
            RingProgressView(value: progress)
        }
    }
}
```

변하지 않을 정보이기 때문에 let으로 선언하였습니다.

## @State

그런데 데이터가 변할 때마다 뷰를 업데이트 해주고 싶은 경우는 어떻게 할까?

예를 들어, 책을 더 읽어서 앱에서 읽은 비율을 업데이트하고 싶은 경우 ‘Update Progress’버튼을 눌러 수정창을 열어야 할 것입니다.

```swift
// 뷰에 필요한 데이터
struct EditorConfig {
    var isEditorPresented = false
    var note = ""
    var progress: Double = 0
    mutating func present(initialProgress: Double) {
        progress = initialProgress
        note = ""
        isEditorPresented = true
    }
}

struct BookView: View {
    @State private var editorConfig = EditorConfig()
    func presentEditor() { editorConfig.present(...) }
    var body: some View {
        ...
        Button(action: presentEditor) { ... }
        ...
    }
}
```

수정창을 킬 것인지를 결정하는 UI 상태를 나타내는 데이터(`isEditorPresented`), 메모와 읽은 비율을 나타낼 데이터(`note`, `progress`)가 뷰에 필요하기 때문에 별도로 `EditorConfig` 구조체로 묶어주었습니다.

그리고 버튼이 눌리면 수정창이 열리도록 `present` 메소드를 통해 데이터를 변경해줍니다.

이렇게 해당 뷰 안에서만 쓰이는 데이터의 경우, 특히 UI의 상태와 관련된 일시적인 데이터들을 변경해가면서 사용하고 싶은 경우에 @State를 사용해 데이터와 뷰 사이의 의존관계를 만들어둡니다.

‘@State를 사용해 데이터와 뷰 사이의 의존관계를 만들어주는 것’의 의미는 정확히 무엇일까요?

![https://velog.velcdn.com/images/nala/post/78251ab3-3540-4f75-bfd9-3895946399e9/image.png](https://velog.velcdn.com/images/nala/post/78251ab3-3540-4f75-bfd9-3895946399e9/image.png)

@State는 SwiftUI에서 가장 간단한 source of truth이자, SwiftUI에 의해 관리되는 값을 읽고 쓸 수 있게 해주는 도구다.

### 가장 간단한 source of truth

UI의 상태에 대한 프로퍼티나(모달을 열 것인지 말 것인지, 토글을 on할 것인지 off할 것인지 등) 앱의 데이터모델이 완성되기 전에 간단히 테스트용으로 데이터의 변화에 따라 뷰를 업데이트하는 것을 시험해보고 싶은 경우, 우리는 **뷰에** @State를 사용해 **데이터의 뿌리**를 둡니다.

이 데이터는 해당 뷰에서 만들어진 데이터이고, 앞으로 다른 곳에서 이 데이터가 필요한 경우 해당 뷰에 있는 데이터를 참조해서 사용하게 될 것입니다.

모든 @State는 Source of Truth입니다.

@State를 선언할 때마다, 해당 뷰가 소유하는 new source of truth를 정의하는 것이기 때문에 같은 값에 대해 여러 뷰에 @State를 선언하는 실수를 주의해야 한다.

### SwiftUI에 의해 관리되는 값

State로 선언한 프로퍼티는 SwiftUI가 관리합니다.

프레임워크가 해당 변수에 대한 영구 저장소를 할당하고, 의존관계를 추적하는 것입니다. 어려운 말 같지만 해당 프로퍼티의 데이터는 뷰에서만 생성되고 사용되기 때문에 SwiftUI가 관리하는 것이 당연한 것 같습니다.

프로퍼티의 라이프사이클을 SwiftUI가 관리하기 때문에 데이터가 바뀔 때마다 뷰가 새로 그려질때도 State의 값을 저장소에 따로 저장해둡니다.

'SwiftUI가 관리한다', '프레임워크가 영구 저장소를 할당한다, 따로 저장한다'는 말이 잘 와닿지 않을 수 있습니다.

좀 더 자세히 설명하자면, @State로 프로퍼티를 정의하는 경우 프레임워크가 해당 데이터를 메모리 어딘가에 저장해놓고, @State 변수는 그 값을 가리키는 포인터가 됩니다.

즉, @State 변수는 값 자체가 아닌 포인터인 것입니다.

### 값을 읽고 쓸 수 있게 해주는 도구

위에서 말한 것처럼 @State 변수는 포인터이기 때문에, 해당 변수의 값을 바뀌어도 포인터가 가리키고 있는 메모리 어딘가의 값을 바꾸는 것이지 @State 변수 값 자체를 바꾸는 것이 아닙니다.

메모리 어딘가에 저장된 실제 값을 [`wrappedValue`](https://developer.apple.com/documentation/swiftui/state/wrappedvalue)라고 하는데, 직접 이 프로퍼티에 접근해 값을 사용하지는 않고 @State로 정의한 프로퍼티로 참조해서 사용하는 것입니다.

따라서, @State를 쓰는 경우 immutable한 View 안에서도 변수의 값을 바꿀 수 있는 것처럼 보입니다.

## @Binding

@State는 source of truth기때문에 여러 뷰에 같은 데이터에 대해 여러개의 @State를 만들면 안된다고 했습니다.

그런데 'Update Progress'버튼을 눌러서 열리는 수정창의 경우, 메모와 읽은 비율을 나타내는 부모뷰의 데이터를 변경해야 합니다.

부모뷰에 있는 source of truth를 참조만 해서 직접 소유하지 않으면서 해당 데이터와 수정창 뷰 사이에 명확한 의존관계를 정의할 수 있는 방법이 바로 @Binding입니다.

```swift
struct BookView: View {
    @State private var editorConfig = EditorConfig()
    var body: some View {
        ...
        ProgressEditor(editorConfig: $editorConfig)
        ...
    }
}

struct ProgressEditor: View {
    @Binding var editorConfig: EditorConfig
    ...
        TextEditor($editorConfig.note)
    ...
}
```

부모뷰가 이니셜라이즈될 때, State 프로퍼티의 바인딩을 자식뷰에 넘겨주는 방식으로 구현합니다.

양방향의 소통 관계를 설정할 수 있습니다.

### $ 접두사

프로퍼티에 $ 기호를 붙이면 State에서 Binding을 생성해  [`projectedValue`](https://developer.apple.com/documentation/swiftui/state/projectedvalue)를 리턴합니다.

### 정리

![https://velog.velcdn.com/images/nala/post/77667e97-61fa-4458-a83b-5604d02ddd67/image.png](https://velog.velcdn.com/images/nala/post/77667e97-61fa-4458-a83b-5604d02ddd67/image.png)

- 변하지 않는 데이터에 대해서는 프로퍼티를 사용할 수 있다.
- 뷰가 소유하는 일시적인 데이터는 `@State`를 사용한다.
- 다른 뷰가 소유한 데이터를 mutate할 때는 `@Binding`을 사용한다.

## 3. SwiftUI 개발 환경을 세팅하고 어떻게 구성되어있는지 확인해보세요!

<aside>
📌

레포에서 클론 받은 후 각자 1주차 브랜치 생성 후 프로젝트 세팅 해주세요!!
기본 구조가 어떻게 되어있는지 확인해보세요~

</aside>

## 4. Preview가 뭘까요?

<aside>
📌

SwiftUI에서 제공하는 Preview 기능을 통해 실시간으로 UI를 미리 볼 수 있습니다. Preview의 기본 설정과 활용법에 대해 알아보세요!

</aside>

### Macro Preview

> Xcode 15와 Swift 5.9 이후, Swift의 Macro를 통해 더 쉽게 Preview를 할 수 있게 되었습니다.
> 

```swift
#Preview {
    ContentView()
}

#Preview("Hello World!") {
    ContentView()
}

```

### SwiftUI Preview 코드

- 기본적으로 SwiftUI의 Preview는 각 SwiftUI 파일 하단에 작성되어 있습니다.
- Xcode에서 처음 SwiftUI 파일을 생성하면 다음과 같은 코드가 하단에 있을 것입니다.

```swift
struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}

```

### 다양한 기기에서 Preview 하기

- 설정에 따라 다르겠지만, Preview 하면 기본적으로 보여주는 기기가 각자 있을 것입니다.
- 다른 기기에서 Preview 하기 위해서는 다음과 같이 코드를 변경하면 됩니다.

```swift
ContentView()
  .previewDevice(PreviewDevice(rawValue: "iPhone SE"))

```

### 한 번에 여러기기에서 Preview 하기

- 여러기기의 Preview를 한 화면에 한 번에 볼 수도 있습니다.
- 다음과 같이 여러개의 ContentView를 Group으로 감싸주면 됩니다.

```swift
struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    Group {
      ContentViewOne()
      ContentViewTwo()
    }
  }
}

```